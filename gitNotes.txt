This file contains all of the Git Notes I will take from reading this book.

(17 Jul 16)

	The first thing I'm doing is adding this file of notes, as well as a script file that will help me keep track of my place in a .pdf file (electronic book)...which, in itself, has been a problem I've been trying to solve for a very long time...electronic books (especially .pdfs) have been something I've been trying to utilze for a very long time, but haven't found a good way.

	The command is 'evince -i page# file_name.pdf &'. This gives me a simple way to update my 'location' in the book (by simply changing the page number after each study session). As well as a means to open it directly where I left off after my previous session!!! Awesome!

CHAPTER 1 NOTES

	Git can be used for more than just source code...it can track changes to all types of files. Git adds very little overhead to this amazing functionality.

	Book mentions 'hierarchical work-flow,' but leaves it undefined.

	Git stores 'snapshots' of all the files in a repository during each commit, which is fundamentally different than other VCSs, which tend to store file 'deltas' that are made during each commit/change. Git stores links to previous files if they go unchanged during a commit.

	Because Git is distributed, it is fast, and doesn't require a network connection to allow individuals/collaborators to continue working.

	Git has 'three' states: modified, staged, committed.
	
		modified = things in your working directory that have been changed.
		staged = things changed in the working directory that have been moved to the index...i.e., 'staged.'...ready for the next snapshot.
		commited = things that have undergone a commit operation, and are saved in the database.

	.git is the actual "Repository."
	The 'working directory' is what appears to be the set of files and folders that appear when you enter a folder that is a "git repository." <- That is IMPORTANT -> The working directory "is a single checkout of one version of the project."

	GIT SETUP

	/etc/gitconfig

	To check on your configuration, run git config --list.

(18 Jul 16)

CHAPTER 2 NOTES
	
	git init builds the .git folder, which before there are any commits, is just a skeleton of a repository. The other way to get a repo is to clone it from an existing repository. (chapter 10 will go into a lot of detail about what kinds of files exist in the .git folder).

	git clone [url/dir] copies (doesn't checkout) a version of the existing repo, which can be used to recreate a project should a centralized server version go down or become corrupted. The command also 'checks out' a working copy of the latest project version. This would be in the 'working directory' (or sandbox).

	git status tells you what branch you are on, as well as whether or not you have diverged from the branch you cloned, and what files you have changed, but not staged, what files are staged (i.e. will be part of the next commit), and whether or not you have untracked files. 'git status -s' gives a much shorter version of what status gives...far less wordy.

	git add <file> takes a file that is not being tracked (as well as one that has been modified, but is being tracked), and stages it for commit.

	You can add a file called .gitignore to make sure that git will not attempt to include certain file types for tracking (such as binaries, and temporarily generated files). There are also exceptions that can be added to the file just in case there are a couple of files that do match a certain pattern that you don't want excluded. The book doesn't address where to place the .gitignore file...I guess it should just be in the main git repo?

	git diff will show you the difference (the exact difference) in files that have changed. git diff (with no arguments) shows changes from the previous commit, that haven't been staged...i.e. the differences between the working area and the previous commit.

	git diff --staged shows what will go into your next commit, and it's differences from your previous commit.

	COMMITTING CHANGES

	(19 Jul 16)

		//BREAK// Something random I just learned is that while you have changed files in the sandbox (i.e. working directory), if you attempt to checkout another branch, git tells you that you'll lose those changes. This likely happens (I assume), because you are replacing your current working directory with another, and it gets over-written (effectively). It suggests that you either commit or "stash" those files...I've yet to learn what "stash" does.

	git commit: the -v option includes what would show up if 'git diff' was executed, making it a much more detailed commit message. -a option allows you to skip the staging area, commiting every file in the working directory/sandbox that has been changed.